diff <- mu.samples.t - mu.samples.c
diff.hist <- hist(diff, main = paste("Histogram of the Difference Posterior Means"))
interval.95.diff = quantile(diff, c(.05,.95))
diff <- mu.samples.t - mu.samples.c
diff.hist <- hist(diff, main = paste("Histogram of the Difference Posterior Means"))
interval.95.diff = quantile(diff, c(.05,.95))
interval.95.diff
?dnorm
y.grid = ppoints(1000)*10-5
plor(dnorm(y.grid, mean=3/2, sd=sqrt(2)))
y.grid = ppoints(1000)*10-5
plot(dnorm(y.grid, mean=3/2, sd=sqrt(2)))
y.grid
minplot = min(marginal.density.values)
maxplot = max(marginal.density.values)
plot(theta,marginal.density.values,type="l",col=3,xlim=c(-5,5),ylim=c(minplot,maxplot),lwd=2,
xlab="y",ylab="p(y)",main="Marginal Density")
y.grid = ppoints(1000)*10-5
marginal.density.values = dnorm(y.grid, mean=3/2, sd=sqrt(2))
minplot = min(marginal.density.values)
maxplot = max(marginal.density.values)
plot(theta,marginal.density.values,type="l",col=3,xlim=c(-5,5),ylim=c(minplot,maxplot),lwd=2,
xlab="y",ylab="p(y)",main="Marginal Density")
y.grid = ppoints(1000)*10-5
marginal.density.values = dnorm(y.grid, mean=3/2, sd=sqrt(2))
minplot = min(marginal.density.values)
maxplot = max(marginal.density.values)
plot(y.grid, marginal.density.values,type="l",col=3,xlim=c(-5,5),ylim=c(minplot,maxplot),lwd=2,
xlab="y",ylab="p(y)",main="Marginal Density")
y.grid = ppoints(1000)*10-5
marginal.density.values = dnorm(y.grid, mean=3/2, sd=sqrt(2))
minplot = min(marginal.density.values)
maxplot = max(marginal.density.values)
plot(y.grid, marginal.density.values,type="l",col=3,xlim=c(-5,8),ylim=c(minplot,maxplot),lwd=2,
xlab="y",ylab="p(y)",main="Marginal Density")
y.grid = ppoints(1000)*13-6.5
marginal.density.values = dnorm(y.grid, mean=3/2, sd=sqrt(2))
minplot = min(marginal.density.values)
maxplot = max(marginal.density.values)
plot(y.grid, marginal.density.values,type="l",col=3,xlim=c(-5,8),ylim=c(minplot,maxplot),lwd=2,
xlab="y",ylab="p(y)",main="Marginal Density")
y.grid = ppoints(1000)*15-6.5
marginal.density.values = dnorm(y.grid, mean=3/2, sd=sqrt(2))
minplot = min(marginal.density.values)
maxplot = max(marginal.density.values)
plot(y.grid, marginal.density.values,type="l",col=3,xlim=c(-5,8),ylim=c(minplot,maxplot),lwd=2,
xlab="y",ylab="p(y)",main="Marginal Density")
### 6B: Grid Sampling
theta.samples = sample(theta, size=1000, replace=TRUE, prob=posterior.points)
hist(theta.samples,main="Posterior Dist. of Theta",xlab="theta",ylab="",yaxt="n",col=)
y <- c(43,44,45,46.5,47.5)
n <- length(y)
post.density.func.6A <- function(theta) {
result <- 1
for (y_i in y) {
result <- result * 1/(1 + (y_i - theta)^2)
}
return(result)
}
theta <- ppoints(1000)*100
posterior.points <- post.density.func.6A(theta)
minplot = min(posterior.points)
maxplot = max(posterior.points)
plot(theta,posterior.points,type="l",col=3,xlim=c(0,100),ylim=c(minplot,maxplot),lwd=2,
xlab="theta",ylab="p(theta|y)",main="Unnormalized Posterior Density")
theta.samples = sample(theta, size=1000, replace=TRUE, prob=posterior.points)
hist(theta.samples,main="Posterior Dist. of Theta",xlab="theta",ylab="",yaxt="n",col=)
theta.samples
min(theta.samples)
max()
max(theta.samples)
x = rcauchy(1, location = theta.samples, scale = 1)
length(x)
rcauchy(1, location = theta.samples, scale = 1)
length(theta.samples)
rcauchy(1000, location = theta.samples, scale = 1)
x = rcauchy(1000, location = theta.samples, scale = 1)
min(x)
max(x)
posterior.predictive.samples = rcauchy(1000, location = theta.samples, scale = 1)
hist(posterior.predictive.samples
,breaks=2000,yaxt="n",ylab="",main="Predictive Dist. of Future Observation", xlab="y")
install.packages("REBayes")
library(REBayes)
par(mfrow = c(1,3))
x <- seq(-5, 6, by = 0.05)
plot(x, 0.9 * dnorm(x,0) + 0.1 * dnorm(x,2), type = "l", + xlab = "x", ylab = expression(g(x)), main = "")
plot(x, 0.9 * dnorm(x,0) + 0.1 * dnorm(x,2), type = "l", xlab = "x", ylab = expression(g(x)), main = "")
?dnorm
plot(x, 0.9 * dnorm(x,0) + 0.1 * dnorm(x,2), type = "l", xlab = "x", ylab = expression(g(x)), main = "")
par(mfrow = c(1,3))
x <- seq(-5, 6, by = 0.05)
plot(x, 0.9 * dnorm(x,0) + 0.1 * dnorm(x,2), type = "l", xlab = "x", ylab = expression(g(x)), main = "")
y <- rep(c(0,2), times = c(900,100)) + rnorm(1000)
y
?rep
z <- GLmix(y)
install.packages("Rmosek")
z <- GLmix(y)
Rmosek::mosek_attachbuilder
library(Rmosek)
mosek_attachbuilder(what_mosek_bindir)
z <- GLmix(y)
?Rmosek::mosek_attachbuilder
install.rmosek
install.rmosek()
mosek_attachbuilder(what_mosek_bindir,
pos=2L, name="Rmosek:builder", warn.conflicts=TRUE)
library(Rmosek)
z <- GLmix(y)
library(Rmosek)
mosek_attachbuilder()
install.rmosek() #this installs a version of rmosek replacing the CRAN  one
install.packages("Rmosek", type="source", INSTALL_opts="--no-multiarch", repos="http://download.mosek.com/R/8")
install.packages("Rmosek", type = "source", INSTALL_opts = "--no-multiarch", repos = "http://download.mosek.com/R/8")
# A simple Gaussian mixture model
par(mfrow = c(1,3))
x <- seq(-5, 6, by = 0.05)
plot(x, 0.9 * dnorm(x,0) + 0.1 * dnorm(x,2), type = "l", xlab = "x", ylab = expression(g(x)), main = "")
y <- rep(c(0,2), times = c(900,100)) + rnorm(1000)
z <- GLmix(y)
library(REBayes)
z <- GLmix(y)
library(REBayes)
library(Rmosek)
# A simple Gaussian mixture model
par(mfrow = c(1,3))
x <- seq(-5, 6, by = 0.05)
plot(x, 0.9 * dnorm(x,0) + 0.1 * dnorm(x,2), type = "l", xlab = "x", ylab = expression(g(x)), main = "")
y <- rep(c(0,2), times = c(900,100)) + rnorm(1000)
z <- GLmix(y)
plot(z, xlab = expression(mu), ylab = expression(f(mu)), main = "") R> plot(x, predict(z,x), type = "l", ylab = expression(delta(x)))
?mosek_attachbuilder
mosek_attachbuilder(NA)
library(Rmosek)
mosek_attachbuilder()
find.package('Rmosek')
mosek_attachbuilder("/Library/mosek")
mosek_attachbuilder("/Library/mosek/9.2/tools/platform/osx64x86/bin")
install.rmosek()
install.rmosek()
library(Rmosek)
example(mosek)
example(mosek)
library(Rmosek)
mosek_attachbuilder("~/mosek/9.2/tools/platform/osx64x86/bin") # this path will be different for your computer
install.rmosek()
library(Rmosek)
example(mosek)
library(REBayes)
library(Rmosek)
par(mfrow = c(1,3))
x <- seq(-5, 6, by = 0.05)
plot(x, 0.9 * dnorm(x,0) + 0.1 * dnorm(x,2), type = "l", xlab = "x", ylab = expression(g(x)), main = "")
y <- rep(c(0,2), times = c(900,100)) + rnorm(1000)
z <- GLmix(y)
plot(z, xlab = expression(mu), ylab = expression(f(mu)), main = "") R> plot(x, predict(z,x), type = "l", ylab = expression(delta(x)))
par(mfrow = c(1,3))
x <- seq(-5, 6, by = 0.05)
plot(x, 0.9 * dnorm(x,0) + 0.1 * dnorm(x,2), type = "l", xlab = "x", ylab = expression(g(x)), main = "")
y <- rep(c(0,2), times = c(900,100)) + rnorm(1000)
z <- GLmix(y)
plot(z, xlab = expression(mu), ylab = expression(f(mu)), main = "")
plot(x, predict(z,x), type = "l", ylab = expression(delta(x)))
library(tidyverse)
library(rstan)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
# read data
#D <- read_csv("design_matrix_0.csv")
D <- read_csv("design_matrix_0.csv", col_types = "ddddddddddcccc")
names(D)
# create dummy variables for the categorical variables
BATTER_IDX_dummies <- D %>% modelr::model_matrix(~ BATTER_IDX)
ORDER_CT_dummies <- D %>% modelr::model_matrix(~ ORDER_CT) %>% select(-`(Intercept)`)
# design matrix
X0 = bind_cols(BATTER_IDX_dummies, ORDER_CT_dummies)
X = as.matrix(X0)
# response variable
y = D$EVENT_WOBA
tto1_dat <- list(n = nrow(X),
p = ncol(X),
X = X,
y = y)
setwd("~/Desktop/TTO_/rstan_0")
# read data
#D <- read_csv("design_matrix_0.csv")
D <- read_csv("design_matrix_0.csv", col_types = "ddddddddddcccc")
names(D)
# create dummy variables for the categorical variables
BATTER_IDX_dummies <- D %>% modelr::model_matrix(~ BATTER_IDX)
ORDER_CT_dummies <- D %>% modelr::model_matrix(~ ORDER_CT) %>% select(-`(Intercept)`)
# design matrix
X0 = bind_cols(BATTER_IDX_dummies, ORDER_CT_dummies)
X = as.matrix(X0)
# response variable
y = D$EVENT_WOBA
tto1_dat <- list(n = nrow(X),
p = ncol(X),
X = X,
y = y)
fit <- stan(file = 'tto1.stan', data = tto1_dat, iter = 1000, chains = 3)
fit
print(fit)
stan_diag(fit)
stan_hist(fit)
stan_hist(fit)
?stan_hist
pars = c("alpha", paste(rep("BATTER_IDX_",k), 2:13, sep = ""), "sigma")
pars
pars = c("alpha", paste(rep("BATTER_IDX_",k), 1:k, rep("]",k), sep = ""), "sigma")
paste("BATTER_IDX_", k)
paste("BATTER_IDX_", 2)
paste(rep("beta[",k), 1:k, rep("]",k), sep = ""), "sigma"
paste(rep("beta[",k), 1:k, rep("]",k), sep = ""), "sigma")
paste(rep("beta[",k), 1:k, rep("]",k), sep = "")
k=4
paste(rep("beta[",k), 1:k, rep("]",k), sep = "")
pars = c("alpha", paste(rep("BATTER_IDX_",13), 2:13, rep("]",13), sep = ""), "sigma")
pars
pars = c("alpha", paste(rep("BATTER_IDX_",13), 2:13, sep = ""), "sigma")
pars
pars = c("alpha", paste(rep("BATTER_IDX_",12), 2:13, sep = ""), "sigma")
pars
pars = c("alpha",
paste(rep("BATTER_IDX_",12), 2:13, sep = ""),
paste(rep("ORDER_CT_",3), 2:4, sep = ""),
"sigma")
pars
stan_hist(fit, pars=pars)
pars = c("alpha",
paste(rep("BATTER_IDX_",12), 2:13, sep = ""),
paste(rep("ORDER_CT_",3), 2:4, sep = "")) #,"sigma")
stan_hist(fit, pars=pars)
k = ncol(X)
pars <- c("alpha", paste(rep("beta[",k), 1:k, rep("]",k), sep = ""), "sigma")
stan_hist(fit, pars=pars)
pars
ncol(X)
stan_hist(fit, include=TRUE)
colnames(X)
X0
BATTER_IDX_dummies <- BATTER_IDX_dummies %>%
relocate(BATTER_IDX2, .after = `(Intercept)`) %>%
relocate(BATTER_IDX3, .after = BATTER_IDX2) %>%
relocate(BATTER_IDX4, .after = BATTER_IDX3) %>%
relocate(BATTER_IDX5, .after = BATTER_IDX4) %>%
relocate(BATTER_IDX6, .after = BATTER_IDX5) %>%
relocate(BATTER_IDX7, .after = BATTER_IDX6) %>%
relocate(BATTER_IDX8, .after = BATTER_IDX7) %>%
relocate(BATTER_IDX9, .after = BATTER_IDX8) %>%
relocate(BATTER_IDX10, .after = BATTER_IDX9) %>%
relocate(BATTER_IDX11, .after = BATTER_IDX10) %>%
relocate(BATTER_IDX12, .after = BATTER_IDX11) %>%
relocate(BATTER_IDX13, .after = BATTER_IDX12)
BATTER_IDX_dummies
ORDER_CT_dummies <- D %>% modelr::model_matrix(~ ORDER_CT) %>% select(-`(Intercept)`)
ORDER_CT_dummies
# design matrix
X0 = bind_cols(BATTER_IDX_dummies, ORDER_CT_dummies)
X = as.matrix(X0)
# response variable
y = D$EVENT_WOBA
X
colnames(X)
tto1_dat <- list(n = nrow(X),
p = ncol(X),
X = X,
y = y)
fit <- stan(file = 'tto1.stan', data = tto1_dat, iter = 1000, chains = 3)
# read data
#D <- read_csv("design_matrix_0.csv")
D <- read_csv("design_matrix_0.csv", col_types = "ddddddddddcccc")
names(D)
# design matrix
X0 = D %>% select(WOBA_CUMU_BAT, WOBA_CUMU_PIT, HAND_MATCH)
X0
X = as.matrix(X0)
X
# response variable
y = D$EVENT_WOBA
y
dim(X)
dim(y)
lenth(y)
nrow(y)
length(y)
tto1_dat <- list(n = nrow(X),
p = ncol(X),
X = X,
y = y)
fit <- stan(file = 'tto1.stan', data = tto1_dat, iter = 1000, chains = 3)
# design matrix
X0 = D %>% select(EVENT_WOBA, WOBA_CUMU_BAT, WOBA_CUMU_PIT, HAND_MATCH) %>% drop_na()
nrow(X0)
# design matrix
X0 = D %>%
select(EVENT_WOBA, WOBA_CUMU_BAT, WOBA_CUMU_PIT, HAND_MATCH) %>% drop_na()
# design matrix
X0 = D %>% select(EVENT_WOBA, WOBA_CUMU_BAT, WOBA_CUMU_PIT, HAND_MATCH) %>% drop_na()
y = X0$EVENT_WOBA
X0 = X0 %>% select(-EVENT_WOBA)
X = as.matrix(X0)
dim(X)
nrow(y)
length(Y)
length(y)
tto1_dat <- list(n = nrow(X),
p = ncol(X),
X = X,
y = y)
fit <- stan(file = 'tto1.stan', data = tto1_dat, iter = 1000, chains = 3)
print(fit)
stan_hist(fit)
names(X)
colnames(X)
tto1_dat <- list(n = nrow(X),
p = ncol(X),
X = X,
y = y)
fit <- stan(file = 'tto1.stan', data = tto1_dat, iter = 1000, chains = 3)
print(fit)
colnames(X)
stan_hist(fit)
library(tidyverse)
library(rstan)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
load(url("http://math.luc.edu/~ebalderama/bayes_resources/data/election_2008_2016.RData"))
load(url("http://math.luc.edu/~ebalderama/bayes_resources/data/election_2008_2016.RData"))
load(stan_ex_gop_data)
load(stan_ex_gop_data.RData)
getwd()
load(stan_ex_gop_data.RData)
load("stan_ex_gop_data.RData")
library(tidyverse)
library(rstan)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
load(url("http://math.luc.edu/~ebalderama/bayes_resources/data/election_2008_2016.RData"))
load("stan_ex_gop_data.RData")
junk <- is.na(Y + rowSums(X))
Y <- Y[!junk]
X <- X[!junk,]
X <- scale(X)
n <- length(Y)
k <- ncol(X)
dim(X)
dat <- list(n = n, k = k, X = X, Y = Y)
dat
dat$n
dat$k
dat$Y
dat <- list(n = n, k = k, X = X, Y = Y)
#fit <- stan(file = 'mlr_flat.stan', data = dat)
fit <- stan(model_code = model_code, data = dat, iter = 1000, chains = 3)
dat <- list(n = n, k = k, X = X, Y = Y)
#fit <- stan(file = 'mlr_flat.stan', data = dat)
fit <- stan(file = 'stan_ex_gop.stan', data = dat, iter = 1000, chains = 3)
print(fit)
stan_hist(fit)
dim(X)
pars <- c("alpha", paste(rep("beta[",k), 1:k, rep("]",k), sep = ""), "sigma")
stan_hist(fit, pars = pars)
stan_dens(fit, pars = pars)
stan_trace(fit, pars = pars)
stan_ac(fit, pars = pars)
stan_ess(fit, pars = pars)
stan_scat(fit, pars = c("beta[6]", "beta[8]"))
library(rstanarm)
post1 <- stan_glm(Y ~ .  ,# + WOBA_CUMU_BAT + WOBA_CUMU_PIT + DAYS_SINCE_SZN_START,
data = as.data.frame(X,Y),
family = gaussian(link = "identity"),
seed = 12345)
post1
stan_hist(fit, pars = pars)
fit
dat <- list(n = n, k = k, X = X, Y = Y)
#fit <- stan(file = 'mlr_flat.stan', data = dat)
fit <- stan(file = 'stan_ex_gop.stan', data = dat, iter = 1000, chains = 3)
fit
library(tidyverse)
library(rstan)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
# read data
#D <- read_csv("design_matrix_0.csv")
D <- read_csv("design_matrix_0.csv", col_types = "ddddddddddcccc")
names(D)
X0 = D %>% select(EVENT_WOBA, WOBA_CUMU_BAT, WOBA_CUMU_PIT) %>% drop_na()
y = X0$EVENT_WOBA # response variable
X0 = X0 %>% select(-EVENT_WOBA)
X = as.matrix(X0) # design matrix
ncol(X)
tto2_dat <- list(n = nrow(X),
p = ncol(X),
X = X,
y = y)
fit <- stan(file = 'tto2.stan', data = tto2_dat, iter = 1000, chains = 3)
fit
colnames(X)
stan_hist(fit)
library(rstanarm)
post1 <- stan_glm(Y ~ .  ,# + WOBA_CUMU_BAT + WOBA_CUMU_PIT + DAYS_SINCE_SZN_START,
data = as.data.frame(X,Y),
family = gaussian(link = "identity"),
seed = 12345)
post1 <- stan_glm(y ~ .  ,# + WOBA_CUMU_BAT + WOBA_CUMU_PIT + DAYS_SINCE_SZN_START,
data = as.data.frame(X,Y),
family = gaussian(link = "identity"),
seed = 12345)
post1 <- stan_glm(y ~ .  ,# + WOBA_CUMU_BAT + WOBA_CUMU_PIT + DAYS_SINCE_SZN_START,
data = as.data.frame(X,y),
family = gaussian(link = "identity"),
seed = 12345)
post1
stan_hist(post1)
stan_hist(fit)
prior(post1)
prior_summary(post1)
1/.17
fit <- stan(file = 'tto2.stan', data = tto2_dat, iter = 1000, chains = 3)
print(fit)
colnames(X)
stan_hist(fit)
library(tidyverse)
library(rstan)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
library(rstanarm)
#prior_i = normal(location = c(.3), scale = c(.03))
#prior1 = normal(location = c(.3), scale = c(.03))
post1 <- stan_glm(EVENT_WOBA ~ BATTER_IDX + ORDER_CT  ,# + WOBA_CUMU_BAT + WOBA_CUMU_PIT + DAYS_SINCE_SZN_START,
data = D,
family = gaussian(link = "identity"),
#prior_intercept = prior_i,
#prior = prior1,
seed = 12345)
# read data
#D <- read_csv("design_matrix_0.csv")
D <- read_csv("design_matrix_0.csv", col_types = "ddddddddddcccc")
names(D)
#prior_i = normal(location = c(.3), scale = c(.03))
#prior1 = normal(location = c(.3), scale = c(.03))
post1 <- stan_glm(EVENT_WOBA ~ BATTER_IDX + ORDER_CT  ,# + WOBA_CUMU_BAT + WOBA_CUMU_PIT + DAYS_SINCE_SZN_START,
data = D,
family = gaussian(link = "identity"),
#prior_intercept = prior_i,
#prior = prior1,
seed = 12345)
nrow(D)
# create dummy variables for the categorical variables
BATTER_IDX_dummies <- D %>% modelr::model_matrix(~ BATTER_IDX)
BATTER_IDX_dummies <- BATTER_IDX_dummies %>%
relocate(BATTER_IDX2, .after = `(Intercept)`) %>%
relocate(BATTER_IDX3, .after = BATTER_IDX2) %>%
relocate(BATTER_IDX4, .after = BATTER_IDX3) %>%
relocate(BATTER_IDX5, .after = BATTER_IDX4) %>%
relocate(BATTER_IDX6, .after = BATTER_IDX5) %>%
relocate(BATTER_IDX7, .after = BATTER_IDX6) %>%
relocate(BATTER_IDX8, .after = BATTER_IDX7) %>%
relocate(BATTER_IDX9, .after = BATTER_IDX8) %>%
relocate(BATTER_IDX10, .after = BATTER_IDX9) %>%
relocate(BATTER_IDX11, .after = BATTER_IDX10) %>%
relocate(BATTER_IDX12, .after = BATTER_IDX11) %>%
relocate(BATTER_IDX13, .after = BATTER_IDX12)
ORDER_CT_dummies <- D %>% modelr::model_matrix(~ ORDER_CT) %>% select(-`(Intercept)`)
# design matrix
X0 = bind_cols(BATTER_IDX_dummies, ORDER_CT_dummies)
X = as.matrix(X0)
# response variable
y = D$EVENT_WOBA
X
colnames(X)
post1
D
names(D)
# create dummy variables for the categorical variables
BATTER_IDX_dummies <- D %>% modelr::model_matrix(~ BATTER_IDX)
BATTER_IDX_dummies <- BATTER_IDX_dummies %>%
relocate(BATTER_IDX2, .after = `(Intercept)`) %>%
relocate(BATTER_IDX3, .after = BATTER_IDX2) %>%
relocate(BATTER_IDX4, .after = BATTER_IDX3) %>%
relocate(BATTER_IDX5, .after = BATTER_IDX4) %>%
relocate(BATTER_IDX6, .after = BATTER_IDX5) %>%
relocate(BATTER_IDX7, .after = BATTER_IDX6) %>%
relocate(BATTER_IDX8, .after = BATTER_IDX7) %>%
relocate(BATTER_IDX9, .after = BATTER_IDX8) %>%
relocate(BATTER_IDX10, .after = BATTER_IDX9) %>%
relocate(BATTER_IDX11, .after = BATTER_IDX10) %>%
relocate(BATTER_IDX12, .after = BATTER_IDX11) %>%
relocate(BATTER_IDX13, .after = BATTER_IDX12)
ORDER_CT_dummies <- D %>% modelr::model_matrix(~ ORDER_CT) %>% select(-`(Intercept)`)
# design matrix
X0 = bind_cols(BATTER_IDX_dummies, ORDER_CT_dummies)
X = as.matrix(X0)
colnames(X)
# response variable
y = D$EVENT_WOBA
lenght(y)
length(y)
dim(X)
post1
tto3_dat <- list(n = nrow(X),
p = ncol(X),
X = X,
y = y)
tto3_dat <- list(n = nrow(X),
p = ncol(X),
X = X,
y = y)
fit <- stan(file = 'tto3.stan', data = tto3_dat, iter = 1000, chains = 3)
